import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Infer TypeScript type from a value
 */
function inferType(value) {
	if (value === null || value === undefined || value === "") {
		return "string";
	}
	if (typeof value === "number") {
		return "number";
	}
	if (typeof value === "boolean") {
		return "boolean";
	}
	return "string";
}

/**
 * Generate TypeScript interface from sample data
 */
function generateInterface(data) {
	if (!data || data.length === 0) {
		throw new Error("No data to generate interface from");
	}

	// Get all unique keys from all records
	const allKeys = new Set();
	for (const row of data) {
		for (const key of Object.keys(row)) {
			allKeys.add(key);
		}
	}

	// Infer types for each key by checking all records
	const keyTypes = {};
	const keyOptional = {};
	for (const key of allKeys) {
		const types = new Set();
		let hasValue = false;
		let missingCount = 0;

		for (const row of data) {
			// Check all records
			if (key in row && row[key] !== "" && row[key] !== null && row[key] !== undefined) {
				types.add(inferType(row[key]));
				hasValue = true;
			} else {
				missingCount++;
			}
		}

		// Determine if field is optional (missing in any record)
		keyOptional[key] = missingCount > 0;

		// Use the most common type, prefer string if mixed or no values found
		keyTypes[key] = types.has("string") || !hasValue ? "string" : types.values().next().value;
	}

	// Generate interface string
	const lines = ["export interface CountyData {"];
	for (const key of Array.from(allKeys).sort()) {
		const safeName =
			key.includes(" ") || key.includes("(") || key.includes("%") || key.includes("-") ? `"${key}"` : key;
		const optional = keyOptional[key] ? "?" : "";
		lines.push(`  ${safeName}${optional}: ${keyTypes[key]};`);
	}
	lines.push("}");

	return lines.join("\n");
}

/**
 * Generate data.ts file from final.json
 */
async function generateDataTs() {
	console.log("Generating data.ts from final.json...\n");

	const finalDir = path.join(__dirname, "..", "..", "data", "final");
	const srcDataDir = path.join(__dirname, "..", "..", "src", "data");
	const finalJsonPath = path.join(finalDir, "final.json");
	const outputPath = path.join(srcDataDir, "data.ts");

	// Read final.json
	console.log("Reading final.json...");
	const finalData = JSON.parse(fs.readFileSync(finalJsonPath, "utf8"));
	console.log(`Loaded ${finalData.length} counties`);

	// Generate TypeScript interface
	console.log("\nGenerating CountyData interface...");
	const interfaceCode = generateInterface(finalData);

	// Generate the full TypeScript file
	const tsContent = `// Auto-generated from final.json
// Do not edit this file manually

${interfaceCode}

export const counties: CountyData[] = ${JSON.stringify(finalData, null, 2)};
`;

	// Ensure src/data directory exists
	if (!fs.existsSync(srcDataDir)) {
		fs.mkdirSync(srcDataDir, { recursive: true });
		console.log(`Created directory: ${srcDataDir}`);
	}

	// Write the file
	fs.writeFileSync(outputPath, tsContent);

	console.log(`\nâœ… Generated data.ts:`);
	console.log(`   Path: ${outputPath}`);
	console.log(`   Counties: ${finalData.length}`);
	console.log(`   Properties: ${Object.keys(finalData[0]).length}`);

	// Show first few properties
	const sampleKeys = Object.keys(finalData[0]).slice(0, 5);
	console.log(`   Sample properties: ${sampleKeys.join(", ")}, ...`);
}

const isMainModule = import.meta.url === `file:///${process.argv[1].replace(/\\/g, "/")}`;
if (isMainModule) {
	console.log("Script executed directly, running generateDataTs...\n");
	generateDataTs().catch((err) => {
		console.error("Error in generateDataTs:", err);
		process.exit(1);
	});
}

export { generateDataTs };
